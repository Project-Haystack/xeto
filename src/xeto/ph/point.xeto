//
// Copyright (c) 2011-2025, Project-Haystack
// Licensed under the Academic Free License version 3.0
//
// History:
//   15 Mar 2025  Auto-generate
//   20 Nov 2025  Brian Frank    Re-orangize using PhEntity
//

// Data point such as a sensor or actuator.
// See [ph.doc::Points] chapter.
Point: PhEntity <abstract> {
  point
  cur:           Marker?
  enum:          Obj?
  equipRef:      Ref?
  his:           Marker?
  kind:          Kind
  maxVal:        Number?
  minVal:        Number?
  pointFunction: PointFunction?
  pointQuantity: Quantity?
  pointSubject:  Phenomenon?
  siteRef:       Ref?
  spaceRef:      Ref?
  systemRef:     MultiRef?
  tz:            TimeZone?
  unit:          Unit?
  writable:      Marker?
  equips:        Query<of:Equip, via:"equipRef+">  // Parent Equips that contain this Point
}

//////////////////////////////////////////////////////////////////////////
// Cur/His/Writable
//////////////////////////////////////////////////////////////////////////

// Point with support to report a "real-time" current value.  By real-time
// we typically mean freshness within the order of a few seconds or at
// most a few minutes.  For systems with direct I/O the current value is
// typically driven by the I/O scan rate. For overlay systems which acquire
// data via a protocol such as BACnet or Modbus then the current value
// is typically refreshed using polling or subscription over a network.
// Also see [ph.doc::Points#cur-points] chapter.
CurPoint: Point <abstract> {
  cur
  curErr:    Str?
  curStatus: CurStatus?
  curVal:    Obj?
}

// Historized point with a history log of timestamp/value pairs.  Points
// marked as historized indicate the system can response to queries via
// the `hisRead` operation to return a trend log of timestamp/value pairs.
//
// There are typically two mechanisms for historization:
//   - the local system performs the historization by logging the
//     point's `curVal` to local storage
//   - in overlay systems a downstream device performs the historization
//     and the local system synchronizes the history data in batch on
//     a periodic basis
//
// Also see [ph.doc::Points#historized-points] chapter.
HisPoint: Point <abstract> {
  his
  hisErr:       Str?
  hisMode:      HisMode?
  hisStatus:    HisStatus?
  hisTotalized: Marker?
}

// Point with writable output using 16-level priority array.  Writable
// points typically are a setpoint or actuator command.  Haystack writable
// points are modeled on the BACnet 16-level priority array with a
// relinquish default which effectively acts as level 17.
//
// The following levels have special behavior:
//  - **Level 1**: highest priority reserved for emergency overrides
//  - **Level 8**: manual override with ability to set timer to expire back to auto
//  - **Default**: implicitly acts as level 17 for relinquish default
//
// The priority array provides for contention resolution when many different
// control applications may be vying for control of a given point. Low level
// applications like scheduling typically control levels 14, 15, or 16. Then
// users can override at level 8. But a higher levels like 2 to 7 can be used
// to trump a user override (for example a demand response energy routine
// that requires higher priority).
//
// The actual value to write is resolved by starting at level 1 and working down
// to relinquish default to find the first non-null value. It is possible for
// all levels to be null, in which case the overall write output is null (which
// in turn may be auto/null to another system). Anytime a null value is written
// to a priority level, we say that level has been set to auto or released (this
// allows the next highest level to take command of the output).
//
// Also see [ph.doc::Points#writable-points] chapter.
WritablePoint: Point <abstract> {
  writable
  writeErr:    Str?
  writeLevel:  Number?
  writeStatus: WriteStatus?
  writeVal:    Obj?
}

//////////////////////////////////////////////////////////////////////////
// Synthetic
//////////////////////////////////////////////////////////////////////////

// See [ph.doc::Synthetics] chapter.
SyntheticPoint: Point <abstract> {
  synthetic
  syntheticModelRef: Ref?
}

// See [ph.doc::Synthetics] chapter.
SyntheticModel: PhEntity {
  syntheticModel
}

// See [ph.doc::Synthetics] chapter.
ComputedPoint: SyntheticPoint <abstract> {
  computed
}

// See [ph.doc::Synthetics] chapter.
ComputedModel: SyntheticModel {
  computedModel
}

// See [ph.doc::Synthetics] chapter.
MlPoint: SyntheticPoint <abstract> {
  ml
}

// See [ph.doc::Synthetics] chapter.
MlModel: SyntheticModel {
  mlModel
  mlIdentificationPeriod: Span?
  mlInputVarRefs:         List?
  mlModelMetrics:         Dict?
  mlModelParameters:      Dict?
  mlOutputVarRef:         Ref?
}

// Machine learning variable representing both model inputs and outputs.
MlVar: PhEntity {
  mlVar
  mlVarFilter: Str?
  mlVarPoint:  Ref?
}

// See [ph.doc::Synthetics] chapter.
SimPoint: SyntheticPoint <abstract> {
  sim
  pointRef:    Ref?
  simScenario: SimScenario?
}

// See [ph.doc::Synthetics] chapter.
SimModel: SyntheticModel {
  simModel
}

